package consistenthash

import (
	"strconv"
	"testing"
)

// TestHashing 测试一致性哈希功能
func TestHashing(t *testing.T) {
	// 创建自定义哈希函数：直接将字符串转换为数字作为哈希值
	// 例如：输入 "2" -> 2, 输入 "11" -> 11
	// 这种哈希函数专门用于测试，确保结果可预测
	hash := New(3, func(key []byte) uint32 {
		i, _ := strconv.Atoi(string(key))
		return uint32(i)
	})

	// 添加初始节点（节点名称也是数字字符串）
	hash.Add("6", "4", "2")

	// 定义测试用例：输入键 -> 期望命中的节点
	testCases := map[string]string{
		"2":  "2", // 键"2"应命中节点"2"
		"11": "2", // 键"11"应命中节点"2"（在环上大于11的第一个节点是12）
		"23": "4", // 键"23"应命中节点"4"（在环上大于23的第一个节点是24）
		"27": "2", // 键"27"应命中节点"2"（环上无大于27的节点，回绕到环首节点2）
	}

	// 验证初始状态下的映射是否正确
	for k, v := range testCases {
		if hash.Get(k) != v {
			t.Errorf("初始状态错误: 键 %s 应命中 %s, 实际命中 %s", k, v, hash.Get(k))
		}
	}

	// 添加新节点"8"
	hash.Add("8")

	// 更新测试用例：添加节点后，"27" 现在应命中 "8"
	testCases["27"] = "8"

	// 验证添加节点后的映射是否正确
	for k, v := range testCases {
		if hash.Get(k) != v {
			t.Errorf("添加节点后错误: 键 %s 应命中 %s, 实际命中 %s", k, v, hash.Get(k))
		}
	}
}

/*
测试说明：

1. 哈希环构建：
   初始节点 "2", "4", "6" 各自生成3个虚拟节点：
     "2" -> 虚拟节点: "02"(2), "12"(12), "22"(22)
     "4" -> 虚拟节点: "04"(4), "14"(14), "24"(24)
     "6" -> 虚拟节点: "06"(6), "16"(16), "26"(26)

   哈希环排序后: [2,4,6,12,14,16,22,24,26]

2. 初始映射逻辑：
   - 键 "2"(2) -> 命中节点2
   - 键 "11"(11) -> 环上第一个>=11的是12 -> 映射到节点"2"
   - 键 "23"(23) -> 环上第一个>=23的是24 -> 映射到节点"4"
   - 键 "27"(27) -> 环上无>=27的值 -> 回绕到环首2 -> 映射到节点"2"

3. 添加节点"8"后：
   新生成虚拟节点: "08"(8), "18"(18), "28"(28)
   新哈希环: [2,4,6,8,12,14,16,18,22,24,26,28]

   键 "27"(27) -> 环上第一个>=27的是28 -> 映射到节点"8"

此测试验证了：
- 虚拟节点的正确生成
- 哈希环的排序和查找
- 节点添加后的数据迁移
- 哈希环回绕逻辑
*/
